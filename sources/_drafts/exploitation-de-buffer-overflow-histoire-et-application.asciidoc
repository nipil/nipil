---
layout: post
title: tagada plouf plouf
---
:toc:
:toc-title: Table des matières

J'ai passé un certain temps de ma vie à rechercher et à les corriger des bugs dans des programmes. Mais dans la vraie vie, on se contente de trouver le problème, on le corrige, on généralise la correction à tous les autres socuis similaires qu'on trouve, et on passe à la suite.

Cependant, quand un certain type de bug est présent, il existe tout un tas de gens intelligents et subtils, qui vont chercher à exploiter les failles dans les programmes, quelles que soient leurs raisons. Et jusqu'ici, je ne m'étais jamais intéressé à la manière dont c'était fait, ni n'avais moi-même effectué ce travail d'instrumentation d'une faille dans un programme.

J'avoue ne pas être totalement étranger au domaine, ayant passé un certain temps étant plus jeune à "cracker" des programmes, ce qui signifie grosso-modo à désassembler un programme et comprendre son fonctionnement au travers d'un débugger, trouver la modification à faire pour obtenir une variante de comportement souhaitée, puis modifier le fichier exécutable pour péréniser ce comportement modifié.

Aujourd'hui, on va essayer de faire comme tout ce qu'on voit dans les films, c'est à dire hacker quelque chose, et exploiter ses faiblesses.

On va se focaliser sur les attack de type "buffer overflow" parce que ce sont les plus connues.

Il existe deux type de "buffer overflow" : ceux se basant sur la pile d'exécution ("stack") et ceux basés sur le tas ("heap")

On s'intéressera ici aux "stack-based buffer overflow"


TODO: integer overflow qui réduit la taille d'un buffer dynamiquement alloué

== Historique

*Attaque* : au début tout était simple

Aucune protection n'était en place, on pouvait faire ce qu'on veut avec la pile ("stack" anglais), on pouvait modifier et exécuter n'importe quelle zone mémoire : les virus modifier leur propre code et celui d'autres programme, on peut pousser des instructions assemblées dans les données et demander qu'elles soient exécutées, c'est la fête du slip.

*Défense*: "Data Execution Prevention" (DEP)

DEP s'appuie sur le "tagging" des zones mémoires, afin d'identifier celles qui sont modifiables (ou non), exécutables (ou non). Ce mécanisme est vérifié à chaque accès mémoire par le processeur, par exemple via link:https://en.wikipedia.org/wiki/NX_bit[le bit NX] des processeurs récents. La technique existe a priori depuis link:https://en.wikipedia.org/wiki/Executable_space_protection[1961] mais n'a été rendue disponible qu'en 2004 via le SP2 de Windows XP et le kernel Linux 2.6.8

*Attaque*: "Return to library" (ret2lib) et "Return to Procedure Linkage Table" (ret2plt)

Elles permettent de contourner DEP, qui empêchent d'exécuter du code dans les données. Ret2lib cherche à "retourner" au _début_ d'une ou plusieurs fonction _du code existant et valide_, afin par exemple de faire une successions d'appels permettant de marquer à nouveau une zone "non sécurisée" comme étant exécutable, contournant ainsi le DEP

*Défense*: "Ascii armoring"

Comme les attaques de type "buffer overflow" sont souvent injectées via des fonctions prévues pour des chaînes de caractère, et que les chaînes de caractères sont terminées par un octet "nul" (0x00), il est "simple" de "couper la chique" à l'attaquant en le forçant à utiliser des adresses contenant des caractère nul, par exemple en plaçant les librairies "tout en bas" de la zone mémoire, où chaque adresse mémoire présente de manière systématique un octet nul

*Attaque*: "Return Oriented Programming" (ROP-chain)

Une variante du "ret2lib", qui au lieu de retourner en début de fonction, et d'utiliser l'ensemble de la fonction, à retourner en fin de fonction (voire même au milieu d'une instruction, ce qui en change le sens) pour n'exécuter que quelques instruction assembleur, puis de retourner ailleur. De proche en proche, en enchainant ces "gadget", on peut exécuter ce que l'on veut.

*Défense*: "Address Space Layout Randomization" (ASLR)

ASLR s'appuie sur le fait qu'il est beaucoup plus facile d'injecter du code dans un programme si celui-ci est toujours chargé au même endroit de la mémoire. En conséquence, cette technique consiste à charger le programme à des zones différentes de la mémoire à chaque exécution. En prérequis, il faut que le programme soit compilé en mode "Position Independant Executable" (PIE) pour qu'il puisse être placé n'importe où. Introduit en 2005 sous Linux via le kernel 2.6.12 et en 2007 sous Windows grâce à Vista

*Attaque*: ASLR force brute ? 16 bits dispo en 32 bits





*Défense*: "Stack Smashing Protector" (SSP)

StackGuard est une extension du compilateur GCC implémentant un SSP qui permet de mieux protéger la pile d'exécution ("stack"). Elle est introduite en 2006 via la version 4.1 de GCC. Il s'agit d'un "canary", c'est à dire le pré-positionnement en début de chaque fonction d'une valeur X sur la pile, et une vérification en fin de fonction que la valeur sur la pile a toujours la valeur attendue : ça permet donc de détecter les modifications non souhaitée de la pile, que ça soit causé par un bug ou une attaque.

*Défense*: "Bounds checking"

Le "bound checking" est une extension du compilateur GCC visant à vérifier les calculs sur les pointeurs et les tableaux.

*Attaque* : ce qui est bloqué par RELRO


*Défense*: "Relocation Read-Only" (RELRO)

En plus d'attaquer le code contenu dans un exécutable, il est aussi possible d'attaquer l'exécutable lui même, son enveloppe, et les données et structures qu'il contient.

http://resources.infosecinstitute.com/an-introduction-to-returned-oriented-programming-linux/#gref

http://blog.siphos.be/2011/07/high-level-explanation-on-some-binary-executable-security/


*Défense*: "Fortify"

L'idée derrière cette méthode, est de profiter des connaissances dont dispose le compilateur du code qu'il compile, pour lui permettre de modifier notre programme afin de le rendre plus robuste. Par exemple, s'il détecte que le buffer de destination fait 30 octets, il remplacera la fonction `strcpy(dst, src)` par un appel à `strncpy(dst, src, 30)` ce qui évite l'attaque qui aurait peut-être été possible à l'origine.

http://pentest.tonyng.net/checksec-sh-now-with-fortify_source-support/

http://resources.infosecinstitute.com/gentoo-hardening-part-3-using-checksec-2/




*Défense*: "RPATH" et "RUNPATH"

https://security.stackexchange.com/questions/161799/why-does-checksec-sh-highlight-rpath-and-runpath-as-security-issues

https://wiki.debian.org/RpathIssue

https://linux.die.net/man/8/ld.so




== Checksec et inventaire des sécurisations


== Activation et désactivation des protections


== Exemple de programme "victime"

.victime.c
----
  #include <stdio.h>
  #include <string.h>
  int main(int argc, char *argv[]) {
    char buffer[4];
    if (argc == 1)
      return 1;
    strcpy(buffer, argv[1]);
    printf("%s\n", buffer);
    return 0;
  }
----

Ce programme contient un buffer de 4 octets, dans lequel on copie le premier argument donné en ligne de commande.

Tant que l'argument a une longueur inférieure ou égale à 4, tout va bien. À partir de 5 caractères, on peut en théorie avoir des soucis. Et on finit toujours pas en avoir un.

.Compilation et vérification
----
gcc -o victime victime.c

# situations correctes

./victime a
a

./victime az
az

./victime aze
aze

./victime aze
aze

./victime azer
azer

# situations à risque

./victime azert
azert

./victime azerty
azerty

./victime azertyu
azertyu

./victime azertyui
azertyui

./victime azertyui
azertyui

./victime azertyuio
azertyuio

./victime azertyuiop
azertyuiop

./victime azertyuiopq
azertyuiopq

# problème avéré

./victime azertyuiopqs
azertyuiopqs
Erreur du bus

./victime azertyuiopqsd
azertyuiopqsd
Instruction non permise

./victime azertyuiopqsdf
azertyuiopqsdf
Erreur de segmentation

./victime azertyuiopqsdfg
azertyuiopqsdfg
Erreur de segmentation
----

Pour résumer, les quatre derniers exemplent montrent que le programme crash, et il y a de fortes chances qu'il soit exploitable (si on sait comment faire, ce qui n'est pas encore mon cas)

== Pré-requis techniques

Ce billet va parler de débugger, d'assembleur, de points d'arrêt, d'agencement mémoire, de pile. Tous ces éléments sont indispensables à la compréhension de la suite, et j'ai trouvé un tas de vidéo sur lesquelles

== Histoire d'une bataille éternelle entre l'attaque et la défense


== Bibliographie
